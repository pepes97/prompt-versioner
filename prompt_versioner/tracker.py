"""Git integration and auto-tracking for prompts."""

import subprocess
from pathlib import Path
from typing import Optional
import hashlib


class GitTracker:
    """Handles Git integration for prompt versioning."""

    def __init__(self, repo_path: Optional[Path] = None):
        """Initialize Git tracker.
        
        Args:
            repo_path: Path to Git repository. Defaults to current directory.
        """
        self.repo_path = repo_path or Path.cwd()
        self._check_git_repo()

    def _check_git_repo(self) -> None:
        """Check if we're in a Git repository."""
        try:
            self._run_git_command(["rev-parse", "--git-dir"])
        except subprocess.CalledProcessError:
            raise RuntimeError(f"Not a git repository: {self.repo_path}")

    def _run_git_command(self, args: list[str]) -> str:
        """Run a git command and return output.
        
        Args:
            args: Git command arguments
            
        Returns:
            Command output as string
        """
        result = subprocess.run(
            ["git"] + args,
            cwd=self.repo_path,
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()

    def get_current_commit(self) -> str:
        """Get current Git commit hash.
        
        Returns:
            Short commit hash (7 characters)
        """
        return self._run_git_command(["rev-parse", "--short", "HEAD"])

    def get_current_branch(self) -> str:
        """Get current Git branch name.
        
        Returns:
            Branch name
        """
        return self._run_git_command(["rev-parse", "--abbrev-ref", "HEAD"])

    def is_dirty(self) -> bool:
        """Check if there are uncommitted changes.
        
        Returns:
            True if there are uncommitted changes
        """
        try:
            output = self._run_git_command(["status", "--porcelain"])
            return bool(output)
        except subprocess.CalledProcessError:
            return False

    def get_version_string(self) -> str:
        """Generate version string based on Git state.
        
        Returns:
            Version string in format: branch-commit[-dirty]
        """
        branch = self.get_current_branch()
        commit = self.get_current_commit()
        dirty = "-dirty" if self.is_dirty() else ""
        return f"{branch}-{commit}{dirty}"

    def install_hooks(self) -> None:
        """Install Git hooks for automatic prompt versioning."""
        hooks_dir = self.repo_path / ".git" / "hooks"
        hooks_dir.mkdir(exist_ok=True)
        
        # Pre-commit hook
        pre_commit_hook = hooks_dir / "pre-commit"
        pre_commit_content = """#!/bin/bash
# Auto-generated by prompt-versioner
# This hook automatically versions prompts before commits

pv auto-version --pre-commit

exit 0
"""
        
        pre_commit_hook.write_text(pre_commit_content)
        pre_commit_hook.chmod(0o755)
        
        # Post-commit hook
        post_commit_hook = hooks_dir / "post-commit"
        post_commit_content = """#!/bin/bash
# Auto-generated by prompt-versioner
# This hook automatically versions prompts after commits

pv auto-version --post-commit

exit 0
"""
        
        post_commit_hook.write_text(post_commit_content)
        post_commit_hook.chmod(0o755)

    def uninstall_hooks(self) -> None:
        """Remove Git hooks installed by prompt-versioner."""
        hooks_dir = self.repo_path / ".git" / "hooks"
        
        for hook_name in ["pre-commit", "post-commit"]:
            hook_path = hooks_dir / hook_name
            if hook_path.exists():
                content = hook_path.read_text()
                if "prompt-versioner" in content:
                    hook_path.unlink()


class PromptHasher:
    """Handles hashing and change detection for prompts."""

    @staticmethod
    def compute_hash(system_prompt: str, user_prompt: str) -> str:
        """Compute hash of prompt pair.
        
        Args:
            system_prompt: System prompt content
            user_prompt: User prompt content
            
        Returns:
            SHA256 hash of concatenated prompts
        """
        combined = f"{system_prompt}\n---\n{user_prompt}"
        return hashlib.sha256(combined.encode()).hexdigest()[:16]

    @staticmethod
    def has_changed(
        old_system: str,
        old_user: str,
        new_system: str,
        new_user: str,
    ) -> bool:
        """Check if prompts have changed.
        
        Args:
            old_system: Original system prompt
            old_user: Original user prompt
            new_system: New system prompt
            new_user: New user prompt
            
        Returns:
            True if prompts differ
        """
        old_hash = PromptHasher.compute_hash(old_system, old_user)
        new_hash = PromptHasher.compute_hash(new_system, new_user)
        return old_hash != new_hash


class AutoTracker:
    """Automatic tracking of prompt changes."""

    def __init__(self, storage, git_tracker: Optional[GitTracker] = None):
        """Initialize auto tracker.
        
        Args:
            storage: PromptStorage instance
            git_tracker: Optional GitTracker instance
        """
        self.storage = storage
        self.git_tracker = git_tracker

    def should_auto_version(
        self,
        name: str,
        system_prompt: str,
        user_prompt: str,
    ) -> bool:
        """Check if prompts should be auto-versioned.
        
        Args:
            name: Prompt name
            system_prompt: System prompt content
            user_prompt: User prompt content
            
        Returns:
            True if prompts have changed since last version
        """
        latest = self.storage.get_latest_version(name)
        
        if latest is None:
            return True
        
        return PromptHasher.has_changed(
            latest["system_prompt"],
            latest["user_prompt"],
            system_prompt,
            user_prompt,
        )

    def auto_version(
        self,
        name: str,
        system_prompt: str,
        user_prompt: str,
        metadata: Optional[dict] = None,
    ) -> Optional[int]:
        """Automatically version prompts if changed.
        
        Args:
            name: Prompt name
            system_prompt: System prompt content
            user_prompt: User prompt content
            metadata: Optional metadata
            
        Returns:
            Version ID if saved, None if unchanged
        """
        if not self.should_auto_version(name, system_prompt, user_prompt):
            return None
        
        # Generate version string
        if self.git_tracker:
            try:
                version = self.git_tracker.get_version_string()
                git_commit = self.git_tracker.get_current_commit()
            except Exception:
                # Fallback if Git operations fail
                version = PromptHasher.compute_hash(system_prompt, user_prompt)
                git_commit = None
        else:
            version = PromptHasher.compute_hash(system_prompt, user_prompt)
            git_commit = None
        
        # Save version
        return self.storage.save_version(
            name=name,
            version=version,
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            metadata=metadata,
            git_commit=git_commit,
        )